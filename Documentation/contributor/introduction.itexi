@c -*- coding: utf-8; mode: texinfo; -*-

@include included/helpus.itexi

@node Introduction to contributing
@chapter Introduction to contributing

This chapter presents a quick overview of ways that people can
help LilyPond.

@menu
* Help us::
* Summary for experienced developers::
* Organization of remote branches::
* Repository directory structure::
* Initializing a repository::
* The Git contributor's cycle::
* Commit message formatting::
* Compiling basics::
* Uploading a patch for review::
* Now start work!::
@end menu


@node Help us
@section Help us

@helpusNeed

@helpusSimple

@helpusAdvanced


@node Summary for experienced developers
@section Summary for experienced developers

If you are already familiar with typical open-source tools, here's
what you need to know:

@itemize
@item @strong{source repository}:
hosted by GNU savannah.

@example
@uref{http://git.savannah.gnu.org/gitweb/?p=lilypond.git}
@end example

@item @strong{environment variables}:
many maintenance scripts, and many instructions in this guide rely on
predefined @ref{Environment variables}.

@item @strong{mailing lists}:
given on @rweb{Contact}.

@item @strong{branches}:

@itemize
@item @code{master}:
base your work from this, but do @strong{not push} to it.

@item @code{staging}:
after a successful review (see below), push here.

@item @code{translation}:
translators should base their work from this, and also push to it.

@item @code{dev/foo}:
feel free to push any new branch name under @code{dev/}.

@end itemize

@item @strong{regression tests}:
also known as @qq{regtests}; this is a collection of more than a
thousand .ly files.  We track the output of those files between
versions.

If a patch introduces any unintentional changes to the regtests,
we will likely reject it -- make sure that you are aware and can
explain any regtest changes.  More info in @ref{Regression tests}.

@item @strong{reviews}:
after finishing work on a patch or branch:

@enumerate
@item
upload it with our custom @code{git-cl}.  In addition to uploading
it to the google rietveld code review tool, this adds a tracker
issue so that we don't lose your patch.  The @qq{status} of your
patch is kept on the issue tracker; see @ref{Issues}.

@example
@uref{https://github.com/gperciva/git-cl}
@end example

Your patch will be given @code{Patch-new} status.  More info in
@ref{Uploading a patch for review}.

@item
If your patch passes some automatic tests, it will be given
@code{Patch-review} status.  This generally happens within 24
hours.

@item
After that, the patch must wait for the next @qq{patch countdown},
which occur 3 times a week.  If there are a lot of patches waiting
for a countdown, a subset of patches are chosen randomly.  When
your patch is put on a countdown, it will be given
@code{Patch-countdown} status.

@item
The countdown is a 48-hour period which gives other developers one
last chance to review the patch.  If no significant problems are
found, your patch will be given @code{Patch-push} status.

@item
You may now either push it to the @code{staging} branch, or email
your patch (created with @w{@code{git format-patch}}) to somebody
who will push it for you.

@end enumerate

@advanced{Yes, this process means that most patches wait between
60-120 hours before reaching @code{master}.  This is unfortunate, but
given our limited resources for reviewing patches and a history of
unintended breakage in @code{master}, this is the best compromise
we have found.}

@c I don't think this is important enough to list here, but I may
@c change my mind and/or leave a link to a later CG section.
@ignore
@item @strong{code style}:
C++ code should be formatted with
@file{scripts/auxiliar/fixcc.py}, which requires
@url{http://astyle.sourceforge.net/, astyle 2.02}.  However, we
are not very strict about this requirement.

At the moment, scheme code should be formatted @qq{like emacs does
it}.  We are working on an automated tool to simplify this step.
However, we are not very strict about this requirement either.
@end ignore

@end itemize

@warning{Contributors on Windows or MacOS X wishing to compile
code or documentation are strongly advised to use our Ubuntu
LilyPond Developer Remix, as discussed in @ref{Quick start}.}



@node Organization of remote branches
@section Organization of remote branches


The main LilyPond repository is organized into @emph{branches} to
facilitate development.  These are often called @emph{remote}
branches to distinguish them from @emph{local} branches you might
create yourself (see @ref{Using local branches}).

The @code{master} branch contains all the source files used to
build LilyPond, which includes the program itself (both stable and
development releases), the documentation (and its translations),
and the website.  Generally, the @code{master} branch is expected
to compile successfully.

The @code{translation} branch is a side branch that
allows translators to work without needing to worry about
compilation problems.  Periodically, the Translation Meister
(after verifying that it doesn't break compilation), will
@emph{merge} this branch into @code{staging} to incorporate
recent translations.  Similarly, the @code{master} branch is
usually merged into the @code{translation} branch after
significant changes to the English documentation.  See
@ref{Translating the documentation} for details.


Most contributors will never need to touch the other branches.  If
you wish to do so, you will need more familiarity with Git; please
see @ref{Other Git documentation}.

@itemize
@item @code{dev/XYZ}:
These branches are for individual developers.  They store code
which is not yet stable enough to be added to the @code{master}
branch.

@item @code{stable/XYZ}:
The branches are kept for archival reasons.

@item @code{archive/XYZ}:
The branches are kept for archival reasons.

@end itemize



@node Repository directory structure
@section Repository directory structure


@c TODO: integrate the roadmap better
@verbatiminclude ROADMAP



@node Initializing a repository
@section Initializing a repository

Once Git is installed, get a copy of the source code:

@example
git clone git://git.sv.gnu.org/lilypond.git ~/lilypond-git
@end example

The above command will put the it in @file{~/lilypond-git}, where
@code{~} represents your home directory.

However, if your internet router filters out connections using the
GIT protocol, or if you experience difficulty connecting via GIT,
you can try these other sources instead of
@code{git://git.sv.gnu.org/lilypond.git}:

@example
ssh://git.sv.gnu.org/srv/git/lilypond.git
http://git.sv.gnu.org/r/lilypond.git
@end example

The SSH protocol can only be used if your system is properly set
up to use it.  Also, the HTTP protocol is slowest, so it should
only be used as a last resort.

@subsubheading Technical details

This creates (within the @file{$LILYPOND_GIT} directory) a
subdirectory called @file{.git/}, which Git uses to keep track of
changes to the repository, among other things.  Normally you don't
need to access it, but it's good to know it's there.


@node The Git contributor's cycle
@section The Git contributor's cycle


Here is a simplified view of the contribution process on Git:

@enumerate
@item
Update your local repository by @emph{pulling} the most recent
updates from the remote repository.

@item
Edit source files within your local repository's @emph{working
directory}.

@item
@emph{Commit} the changes you've made to a local @emph{branch}.

@item
Generate a @emph{patch} to share your changes with the developers.
@end enumerate


@node Commit message formatting
@section Commit message formatting

Your commit message should begin with a one-line summary
describing the change (no more than 50 characters long), and if
necessary a blank line followed by several lines giving the
details:

@c $ git log -1 --pretty=medium 4d6f1e5
@example
Doc: add Baerenreiter and Henle solo cello suites

Added comparison of solo cello suite engravings to new essay with
high-res images, fixed cropping on Finale example.
@end example

Commit messages often start with a short prefix describing the
general location of the changes.  If a commit affects the
documentation in English (or in several languages simultaneously)
the commit message should be prefixed with @qq{Doc:@tie{}}.  If
the commit affects only one of the translations, the commit
message should be prefixed with @qq{Doc-@var{**}:@tie{}}, where
@var{**} is the two-letter language code.  Commits that affect the
website should use @qq{Web:@tie{}} for English, and
@qq{Web-@var{**}:@tie{}} for the other languages.  Also, changes
to a single file are often prefixed with the name of the file
involved.  Visit the links listed in @ref{Understanding commits}
for examples.




@node Compiling basics
@section Compiling basics

LilyDev is our @q{remix} of Ubuntu which contains all the
necessary dependencies to do lilypond development; for more
information, see @rcontrib{LilyDev}.

@subsubheading Preparing the build

To prepare the build directory, enter (or copy&paste) the below
text.  This should take less than a minute.

@c we heavily recommend the out-of-tree build; do not change this!

@example
cd $LILYPOND_GIT
sh autogen.sh --noconfigure
mkdir -p build/
cd build/
../configure
@end example

@subsubheading Building @code{lilypond}

Compiling lilypond will likely take between 5 and 60 minutes,
depending on your computer's speed and available RAM.  We
recommend that you minimize the terminal window while it is
building; this can have a non-negligible effect on compilation
speed.

@example
cd $LILYPOND_GIT/build/
make
@end example

You may run the compiled @code{lilypond} with:

@example
cd $LILYPOND_GIT/build/
out/bin/lilypond my-file.ly
@end example

@subsubheading Building the documentation

Compiling the documentation is a much more involved process, and
will likely take 2 to 10 hours.

@example
cd $LILYPOND_GIT/build/
make
make doc
@end example

The documentation is put in @file{out-www/offline-root/}.  You may
view the html files by entering the below text; we recommend that
you bookmark the resulting page:

@example
firefox $LILYPOND_GIT/build/out-www/offline-root/index.html
@end example

@subsubheading Installing

Don't.  There is no reason to install lilypond within LilyDev.
All development work can (and should) stay within the
@file{$LILYPOND_GIT} directory, and any personal composition
or typesetting work should be done with an official GUB release.


@subsubheading Problems and other options

To select different build options, or isolate certain parts of the
build, or to use multiple CPUs while building, read
@ref{Compiling}.

In particular, contributors working on the documentation should be
aware of some bugs in the build system, and should read the
workarounds in @ref{Generating documentation}.




@node Uploading a patch for review
@section Uploading a patch for review

Any non-trivial change should be uploaded to our @qq{Rietveld}
code review website:

@example
@uref{http://codereview.appspot.com/}
@end example

@subsubheading @command{git-cl} install

LilyDev users should skip over these @q{install} instructions.

@enumerate

@item
Install @command{git-cl} by entering:

@example
git clone https://github.com/gperciva/git-cl.git
@end example

If that command fails for some reason, try this instead:

@example
git clone git://github.com/gperciva/git-cl.git
@end example

@item
Add the @file{git-cl/} directory to your PATH,
or create a symbolic link to the @command{git-cl}
and @command{upload.py} scripts in one of your PATH
directories (such as @file{$HOME/bin}).

In Ubuntu (and LilyDev), you can add directories to PATH
by adding this line to a hidden file @file{.bashrc},
located in your home directory:

@example
PATH=~/type-here-directory-containing-git-cl:"$@{PATH@}"
@end example

@end enumerate

@subsubheading @command{git-cl} configuration

LilyDev users should perform these @q{configuration} instructions.

@enumerate
@item
You must have a google account; please create one if you do not
have one already.

Note that a google account does not need to be a gmail account; you can
use any email address for your google account when you sign up.

@item
Move into the top source directory and then configure @command{git
cl} with the following commands:

@example
cd $LILYPOND_GIT
git cl config
@end example

For the @qq{Rietveld server} question, the default value
(@qq{codereview.appspot.com}) should be accepted by
answering with a newline (CR).

The @qq{CC list} question should be answered with:

@example
lilypond-devel@@gnu.org
@end example

The @qq{Tree status URL} value should be left blank.  So should
the @qq{ViewVC URL} value, since it is used by @command{git cl
dcommit} which is only for repositories which use @command{git
svn} (LilyPond doesn't).

@end enumerate

@subsubheading Uploading patch set

@warning{Unless you are familiar with branches, only work on one
set of changes at once.}

There are two methods, depending on your git setup.

@itemize
@item
@strong{Master branch}: (easy option, and used in @command{lily-git.tcl})

If you added your patch to @code{master}, then:

@example
git pull -r
git cl upload origin/master
@end example

@c Mention staging here?
If you have git push ability, make sure that you @emph{remove}
your patch (with @command{git rebase} or @command{git reset})
before pushing other stuff.

@c don't make this one an @example; we don't want to make it easy
@c for people to use this accidently
Notifications of patches are automatically added to our issue
tracker to reduce the chance of patches getting lost.  To suppress
this (not recommended), add the @code{-n / --no-code-issue}
option.

@item
@strong{Separate branch}: (complicated option)

Ensure your changes are committed in a separate branch, which
should differ from the reference branch to be used by just the
changes to be uploaded.  If the reference branch is to be
origin/master, ensure this is up-to-date.  If necessary, use git
rebase to rebase the branch containing the changes to the head of
origin/master.  Finally, check out branch with the changes and
enter the command:

@example
git cl upload <reference SHA1 ID>
@end example

@noindent
where <reference SHA1 ID> is the SHA1 ID of the commit to be used
as a reference source for the patch.  Generally, this will be the
SHA1 ID of origin/master, and in that case the command:

@example
git cl upload origin/master
@end example

@noindent
can be used.

@end itemize

After prompting for your Google email address and password, the
patch set will be posted to Rietveld, and you will be given a URL
for your patch.

@warning{Some installations of git-cl fail when uploading a patch
with certain filename extensions.  If this happens, it can
generally be fixed by editing the list of exceptions at top of
@file{git-cl.py}.}

@subsubheading Announcing your patch set

You should then announce the patch by logging into the code review
issue webpage and using @qq{Publish + Mail Comments} to add a
(mostly bogus) comment to your issue.  The text of your comment
will be sent to our developer mailing list.

@warning{There is no automatic notification of a new patch; you
must add a comment yourself.}

@subsubheading Revisions

As revisions are made in response to comments, successive patch sets
for the same issue can be uploaded by reissuing the git-cl command
with the modified branch checked out.

Sometimes in response to comments on revisions, the best way to
work may require creation of a new branch in git.  In order to
associate the new branch with an existing Rietveld issue,
the following command can be used:

@example
git cl issue issue-number
@end example

@noindent
where @code{issue-number} is the number of the existing Rietveld
issue.

@subsubheading Resetting git cl

If @command{git cl} becomes confused, you can @qq{reset} it by
running:

@example
git cl issue 0
@end example

@subsubheading Wait for a countdown

Your patch will be available for reviews for the next few hours or
days.  Three times a week, patches with no known problems are
gathered into a @qq{patch countdown} and their status changed to
@code{patch-countdown}.  The countdown is a 48-hour waiting period
in which any final reviews or complaints should be made.

During the countdown, your patch may be set to
@code{patch-needs_work}, indicating that you should fix something
(or at least discuss why the patch needs no modification).  If no
problems are found, the patch will be set to @code{patch-push}.

Once a patch has @code{patch-push}, it should be sent to your
mentor for uploading.  If you have git push ability, look at
@ref{Pushing to staging}.


@node Now start work!
@section Now start work!

LilyDev users may now skip to the chapter which is aimed at
their intended contributions:

@itemize
@item @ref{Documentation work}
@item @ref{Translating the documentation}
@item @ref{Website work}
@item @ref{Regression tests}
@item @ref{Programming work}
@end itemize

These chapters are mainly intended for people not using LilyDev,
but they contain extra information about the
@qq{behind-the-scenes} activities.  We recommend that you read
these at your leisure, a few weeks after beginning work with
LilyDev.

@itemize
@item @ref{Working with source code}
@item @ref{Compiling}
@end itemize


